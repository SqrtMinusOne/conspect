### Задача с бананами
Имеется доска размером $5 \times 5$. Обезьяна может двигаться вправо и вверх.

Вывести кратчайший путь до банана.

```prolog
start(1,1).
stop(4,4).
go(Path) :- start(X, Y), move(X, Y, [], Path).
move(X, Y, P, [m(X, Y) | P]) :- stop(X, Y).
move(X, Y, From, To) :- X < 5, X1 is X + 1, move(X1, Y, [m(X, Y) | From], To).
move(X, Y, From, To) :- Y < 5, Y1 is Y + 1, move(X, Y1, [m(X, Y) | From], To).
```
Первый параметр - `From` - инициализируется пустым списком и накапливает каждый вновь выполненный шаг `m(X, Y)`.

Второй аргумент - `To` - рекурсивно возвращает результат, когда добрались до банана.

```prolog
| ?- go(P).

P = [m(4,4),m(4,3),m(4,2),m(4,1),m(3,1),m(2,1),m(1,1)] ? a

P = [m(4,4),m(4,3),m(4,2),m(3,2),m(3,1),m(2,1),m(1,1)]

P = [m(4,4),m(4,3),m(3,3),m(3,2),m(3,1),m(2,1),m(1,1)]

P = [m(4,4),m(3,4),m(3,3),m(3,2),m(3,1),m(2,1),m(1,1)]

P = [m(4,4),m(4,3),m(4,2),m(3,2),m(2,2),m(2,1),m(1,1)]

P = [m(4,4),m(4,3),m(3,3),m(3,2),m(2,2),m(2,1),m(1,1)]

P = [m(4,4),m(3,4),m(3,3),m(3,2),m(2,2),m(2,1),m(1,1)]

P = [m(4,4),m(4,3),m(3,3),m(2,3),m(2,2),m(2,1),m(1,1)]

P = [m(4,4),m(3,4),m(3,3),m(2,3),m(2,2),m(2,1),m(1,1)]

P = [m(4,4),m(3,4),m(2,4),m(2,3),m(2,2),m(2,1),m(1,1)]

P = [m(4,4),m(4,3),m(4,2),m(3,2),m(2,2),m(1,2),m(1,1)]

P = [m(4,4),m(4,3),m(3,3),m(3,2),m(2,2),m(1,2),m(1,1)]

P = [m(4,4),m(3,4),m(3,3),m(3,2),m(2,2),m(1,2),m(1,1)]

P = [m(4,4),m(4,3),m(3,3),m(2,3),m(2,2),m(1,2),m(1,1)]

P = [m(4,4),m(3,4),m(3,3),m(2,3),m(2,2),m(1,2),m(1,1)]

P = [m(4,4),m(3,4),m(2,4),m(2,3),m(2,2),m(1,2),m(1,1)]

P = [m(4,4),m(4,3),m(3,3),m(2,3),m(1,3),m(1,2),m(1,1)]

P = [m(4,4),m(3,4),m(3,3),m(2,3),m(1,3),m(1,2),m(1,1)]

P = [m(4,4),m(3,4),m(2,4),m(2,3),m(1,3),m(1,2),m(1,1)]

P = [m(4,4),m(3,4),m(2,4),m(1,4),m(1,3),m(1,2),m(1,1)]

(4 ms) no
```

Можно обернуть список с помощью `reverse` или сохранять координаты при возврате из рекурсии:
```prolog
start(1,1).
stop(4,4).
go(Path) :- start(X, Y), move(X, Y, [], Path).
move(X, Y, P, [m(X, Y) | P]) :- stop(X, Y).
move(X, Y, From, [m(X, Y) | To]) :- X < 5, X1 is X + 1, move(X1, Y, From, To).
move(X, Y, From, [m(X, Y) | To]) :- Y < 5, Y1 is Y + 1, move(X, Y1, From, To).
```

В таком случае путь будет выведен в обратном порядке:
```prolog
| ?- go(P).

P = [m(1,1),m(2,1),m(3,1),m(4,1),m(4,2),m(4,3),m(4,4)] ? ;

P = [m(1,1),m(2,1),m(3,1),m(3,2),m(4,2),m(4,3),m(4,4)] ? ;

P = [m(1,1),m(2,1),m(3,1),m(3,2),m(3,3),m(4,3),m(4,4)] ?
```
